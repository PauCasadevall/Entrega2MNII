import numpy as np
import matplotlib.pyplot as plt

############## definim alguns paràmetres que utilitzarem ################3

e=0.0167
G=6.67430e-11 # en SI
M=1.989e30 # en SI
l=4.4551e15 # en SI
d0 = 1e11 * 1.496 #en SI
t0 = 3600 #en SI
mu = G/((d0**3)/(t0**2*M)) #en SI

#condicions inicials de la posició i la velocitat per components cartesianes 
r0x=-2.546*1e10
r0y=14.49*1e10
v0x=-29.819*1e3
v0y=-5.280*1e3

r0 = np.array([r0x,r0y ], dtype=float)
v0 = np.array([v0x, v0y], dtype=float)

#normalitzem
r0_n = r0/d0
v0_n = v0*t0/d0





################# mètode 1: RK-2 #####################3


# Definim les funció d'acceleració

def acc_2(r,mu):
    # r serà un np.array de forma (2,) amb la posició [x,y]
  rn = np.linalg.norm(r)   # És la norma de r
  return -mu * r / rn**3

def rk2(r0,v0,mu,h,N):
  r0 = np.asarray(r0, dtype=float)       # Garantim tipus i forma
  v0 = np.asarray(v0, dtype=float)
  d  = r0.size                           # dimensió: 2 o 3

  r_2 = np.zeros((N+1,d), dtype=float)
  v_2 = np.zeros((N+1,d), dtype=float)
  t_2 = np.zeros(N+1, dtype=float)

  r_2[0] = r0
  v_2[0] = v0
  t_2[0] = 0.0

  for i in range(N):

    K1r_2 = h * v_2[i]
    K1v_2 = h * acc_2(r_2[i],mu)

    r_mid = r_2[i] + 0.5 * K1r_2
    v_mid = v_2[i] + 0.5 * K1v_2

    K2r_2 = h * v_mid
    K2v_2 = h * acc_2(r_mid,mu)

    r_2[i+1] = r_2[i] + K2r_2
    v_2[i+1] = v_2[i] + K2v_2
    t_2[i+1] = t_2[i] + h

  return t_2,r_2,v_2






N = 200000
h = 1e-1

t_2,r_2,v_2 = rk2(r0_n,v0_n,mu,h,N)


x_2 = 1.496e11 * r_2[:, 0]
y_2 = 1.496e11 * r_2[:, 1]



############ mètode 2: RK-4 #####################


# Definim les funció d'acceleració

def acc_4(r,mu):
    # r serà un np.array de forma (2,) amb la posició [x,y]
  rn = np.linalg.norm(r)   # És la norma de r
  return -mu * r / rn**3

def rk4(r0,v0,mu,h,N):
  r0 = np.asarray(r0, dtype=float)       # Garantim tipus i forma
  v0 = np.asarray(v0, dtype=float)
  d  = r0.size                           # dimensió: 2 o 3

  r_4 = np.zeros((N+1,d), dtype=float)
  v_4 = np.zeros((N+1,d), dtype=float)
  t_4 = np.zeros(N+1, dtype=float)

  r_4[0] = r0
  v_4[0] = v0
  t_4[0] = 0.0

  for i in range(N):

    K1r_4 = v_4[i]
    K1v_4 = acc_4(r_4[i],mu)

    r_1_4 = r_4[i] + (h/2) * K1r_4
    v_1_4 = v_4[i] + (h/2) * K1v_4

    K2r_4 = v_1_4
    K2v_4 = acc_4(r_1_4,mu)

    r_2_4 = r_4[i] + (h/2) * K2r_4
    v_2_4 = v_4[i] + (h/2) * K2v_4

    K3r_4 = v_2_4
    K3v_4 = acc_4(r_2_4,mu)

    r_3_4 = r_4[i] + h * K3r_4
    v_3_4 = v_4[i] + h * K3v_4

    K4r_4 = v_3_4
    K4v_4 = acc_4(r_3_4,mu)

    r_4[i+1] = r_4[i] + (h/6) * (K1r_4 + 2*K2r_4 + 2*K3r_4 + K4r_4)
    v_4[i+1] = v_4[i] + (h/6) * (K1v_4 + 2*K2v_4 + 2*K3v_4 + K4v_4)
    t_4[i+1] = t_4[i] + h

  return t_4,r_4,v_4


N = 200000
h = 1e-1

t_4,r_4,v_4 = rk4(r0_n,v0_n,mu,h,N)


x_4 = 1.496e11 * r_4[:, 0]
y_4 = 1.496e11 * r_4[:, 1]



####################### mètode 3: solució analítica ###################



def grafic_analitic(l,G,M,e,theta):
  return l**2/(G*M*(1+e*np.cos(theta)))

valors_angles=np.linspace(0,2*np.pi, 300)
valors_dist_radials=grafic_analitic(l,G,M,e,valors_angles)



####################### gràfics #################################
plt.figure()
plt.plot(x_4, y_4, label='Trajectòria (RK-4)', color='maroon')
plt.plot(x_2, y_2, label='Trajectòria (RK-2)', color="seagreen", linestyle='None', marker='o', markersize=0.1)
plt.plot(valors_dist_radials*np.cos(valors_angles),valors_dist_radials*np.sin(valors_angles),label="Trajectòria analítica de la Terra") #solució analítica      

plt.scatter(0,0,label="Sol",color="red")
plt.gca().set_aspect('equal', adjustable='box')
plt.xlabel('x (m)')
plt.legend(loc="center left", bbox_to_anchor=(1, 0.5))
plt.ylabel('y (m)')
plt.grid(False)
plt.tick_params(axis='both',which='both',direction='in',top=True,right=True,length=6,width=1)
plt.show()




